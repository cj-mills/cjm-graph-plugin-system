# Core Data Structures


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## SourceRef

A pointer to external data residing in another plugin’s domain. Used to
anchor graph nodes to ground truth (e.g., a specific transcript segment
from a transcription plugin).

This enables **federation** via DuckDB - a query can join graph nodes
with their source data across isolated plugin databases.

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/core.py#L19"
target="_blank" style="float:right; font-size:smaller">source</a>

### SourceRef

``` python

def SourceRef(
    plugin_name:str, table_name:str, row_id:str, segment_slice:Optional=None
)->None:

```

*A pointer to external data in another plugin’s domain.*

``` python
# Test SourceRef creation
ref = SourceRef(
    plugin_name="cjm-transcription-plugin-voxtral-hf",
    table_name="transcriptions",
    row_id="b0ceddd3-1234-5678-9abc-def012345678",
    segment_slice="timestamp:00:10-00:30"
)

print(f"SourceRef: {ref}")
print(f"As dict: {ref.to_dict()}")
```

    SourceRef: SourceRef(plugin_name='cjm-transcription-plugin-voxtral-hf', table_name='transcriptions', row_id='b0ceddd3-1234-5678-9abc-def012345678', segment_slice='timestamp:00:10-00:30')
    As dict: {'plugin_name': 'cjm-transcription-plugin-voxtral-hf', 'table_name': 'transcriptions', 'row_id': 'b0ceddd3-1234-5678-9abc-def012345678', 'segment_slice': 'timestamp:00:10-00:30'}

``` python
# Test without optional segment_slice
ref_minimal = SourceRef(
    plugin_name="cjm-transcription-plugin-whisper",
    table_name="segments",
    row_id="job-123"
)
print(f"Minimal SourceRef: {ref_minimal}")
```

    Minimal SourceRef: SourceRef(plugin_name='cjm-transcription-plugin-whisper', table_name='segments', row_id='job-123', segment_slice=None)

## GraphNode

Represents an entity in the Context Graph. Each node has:

- **id**: Unique identifier (UUID)
- **label**: Node type (e.g., “Person”, “Concept”, “Correction”)
- **properties**: Arbitrary key-value data
- **sources**: Links to external plugin data for provenance tracking

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/core.py#L32"
target="_blank" style="float:right; font-size:smaller">source</a>

### GraphNode

``` python

def GraphNode(
    id:str, label:str, properties:Dict=<factory>, sources:List=<factory>
)->None:

```

*Represents an entity in the Context Graph.*

``` python
import uuid

# Test SourceRef creation
ref = SourceRef(
    plugin_name="cjm-transcription-plugin-voxtral-hf",
    table_name="transcriptions",
    row_id="b0ceddd3-1234-5678-9abc-def012345678",
    segment_slice="timestamp:00:10-00:30"
)

print(f"SourceRef: {ref}")
print(f"As dict: {ref.to_dict()}")

# Test GraphNode creation with sources
node = GraphNode(
    id=str(uuid.uuid4()),
    label="Person",
    properties={"name": "Alice", "role": "speaker"},
    sources=[ref]  # Link to transcript segment
)

print(f"GraphNode: {node}")
print(f"\nAs dict:\n{json.dumps(node.to_dict(), indent=2)}")
```

    SourceRef: SourceRef(plugin_name='cjm-transcription-plugin-voxtral-hf', table_name='transcriptions', row_id='b0ceddd3-1234-5678-9abc-def012345678', segment_slice='timestamp:00:10-00:30')
    As dict: {'plugin_name': 'cjm-transcription-plugin-voxtral-hf', 'table_name': 'transcriptions', 'row_id': 'b0ceddd3-1234-5678-9abc-def012345678', 'segment_slice': 'timestamp:00:10-00:30'}
    GraphNode: GraphNode(id='efb79afb-4344-4142-aa09-d2715a822eaa', label='Person', properties={'name': 'Alice', 'role': 'speaker'}, sources=[SourceRef(plugin_name='cjm-transcription-plugin-voxtral-hf', table_name='transcriptions', row_id='b0ceddd3-1234-5678-9abc-def012345678', segment_slice='timestamp:00:10-00:30')])

    As dict:
    {
      "id": "efb79afb-4344-4142-aa09-d2715a822eaa",
      "label": "Person",
      "properties": {
        "name": "Alice",
        "role": "speaker"
      },
      "sources": [
        {
          "plugin_name": "cjm-transcription-plugin-voxtral-hf",
          "table_name": "transcriptions",
          "row_id": "b0ceddd3-1234-5678-9abc-def012345678",
          "segment_slice": "timestamp:00:10-00:30"
        }
      ]
    }

``` python
# Test minimal node (no properties, no sources)
concept = GraphNode(
    id=str(uuid.uuid4()),
    label="Concept"
)
print(f"Minimal node: {concept.to_dict()}")
```

    Minimal node: {'id': '6c354a53-a620-4bb7-adf2-dc9583915d5d', 'label': 'Concept', 'properties': {}, 'sources': []}

## GraphEdge

Represents a typed relationship between two nodes. Edges are directional
(source → target) and can carry properties.

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/core.py#L50"
target="_blank" style="float:right; font-size:smaller">source</a>

### GraphEdge

``` python

def GraphEdge(
    id:str, source_id:str, target_id:str, relation_type:str, properties:Dict=<factory>
)->None:

```

*Represents a relationship between two nodes.*

``` python
# Create two nodes and an edge between them
person_id = str(uuid.uuid4())
concept_id = str(uuid.uuid4())

person_node = GraphNode(id=person_id, label="Person", properties={"name": "Bob"})
concept_node = GraphNode(id=concept_id, label="Concept", properties={"name": "Machine Learning"})

edge = GraphEdge(
    id=str(uuid.uuid4()),
    source_id=person_id,
    target_id=concept_id,
    relation_type="MENTIONS",
    properties={"confidence": 0.95, "timestamp": "00:15:30"}
)

print(f"Edge: {person_node.properties['name']} --[{edge.relation_type}]--> {concept_node.properties['name']}")
print(f"\nAs dict: {edge.to_dict()}")
```

    Edge: Bob --[MENTIONS]--> Machine Learning

    As dict: {'id': '2b4057bd-4199-4c72-a2da-158d1eb5f886', 'source_id': '205355aa-3dae-426a-a7cd-2ec340dd94b5', 'target_id': '5217de9d-ba75-4443-bea9-18b0a2b3cdfc', 'relation_type': 'MENTIONS', 'properties': {'confidence': 0.95, 'timestamp': '00:15:30'}}

## GraphContext

Container for graph query results (a subgraph). Implements
`FileBackedDTO` for zero-copy transfer of large subgraphs between Host
and Worker processes.

When passed through `RemotePluginProxy`, large GraphContext objects are
automatically serialized to temp files rather than sent inline via JSON.

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/core.py#L64"
target="_blank" style="float:right; font-size:smaller">source</a>

### GraphContext

``` python

def GraphContext(
    nodes:List, edges:List, metadata:Dict=<factory>
)->None:

```

*Container for graph query results (a subgraph).*

``` python
# Create two nodes and an edge between them
person_id = str(uuid.uuid4())
concept_id = str(uuid.uuid4())

person_node = GraphNode(id=person_id, label="Person", properties={"name": "Bob"})
concept_node = GraphNode(id=concept_id, label="Concept", properties={"name": "Machine Learning"})

edge = GraphEdge(
    id=str(uuid.uuid4()),
    source_id=person_id,
    target_id=concept_id,
    relation_type="MENTIONS",
    properties={"confidence": 0.95, "timestamp": "00:15:30"}
)

print(f"Edge: {person_node.properties['name']} --[{edge.relation_type}]--> {concept_node.properties['name']}")
print(f"\nAs dict: {edge.to_dict()}")

# Test GraphContext creation
context = GraphContext(
    nodes=[person_node, concept_node],
    edges=[edge],
    metadata={"query": "neighbors of Bob", "depth": 1}
)

print(f"GraphContext: {len(context.nodes)} nodes, {len(context.edges)} edges")
print(f"Metadata: {context.metadata}")

# Test FileBackedDTO protocol
print(f"Implements FileBackedDTO: {isinstance(context, FileBackedDTO)}")

# Test to_temp_file (this is what the Proxy calls)
temp_path = context.to_temp_file()
print(f"Saved to temp file: {temp_path}")

# Verify file exists and content
import os
print(f"File exists: {os.path.exists(temp_path)}")
print(f"File size: {os.path.getsize(temp_path)} bytes")

# Read back and verify
with open(temp_path) as f:
    content = json.load(f)
print(f"\nFile content keys: {content.keys()}")
print(f"Nodes count: {len(content['nodes'])}")

# Clean up
os.unlink(temp_path)
```

    Edge: Bob --[MENTIONS]--> Machine Learning

    As dict: {'id': '06de15fd-cf41-4dbb-90e0-d875202c148e', 'source_id': '77f4111e-8b2b-41fe-882b-bb7c3fc67ff7', 'target_id': '88eb934d-0309-4cfd-badb-345f1f508cae', 'relation_type': 'MENTIONS', 'properties': {'confidence': 0.95, 'timestamp': '00:15:30'}}
    GraphContext: 2 nodes, 1 edges
    Metadata: {'query': 'neighbors of Bob', 'depth': 1}
    Implements FileBackedDTO: True
    Saved to temp file: /tmp/tmp4aoorh7a.json
    File exists: True
    File size: 561 bytes

    File content keys: dict_keys(['nodes', 'edges', 'metadata'])
    Nodes count: 2

``` python
# Test from_file round-trip
temp_path = context.to_temp_file()
loaded = GraphContext.from_file(temp_path)

print(f"Original: {len(context.nodes)} nodes, {len(context.edges)} edges")
print(f"Loaded:   {len(loaded.nodes)} nodes, {len(loaded.edges)} edges")
print(f"Node labels match: {[n.label for n in context.nodes] == [n.label for n in loaded.nodes]}")
print(f"Edge types match: {[e.relation_type for e in context.edges] == [e.relation_type for e in loaded.edges]}")

os.unlink(temp_path)
```

    Original: 2 nodes, 1 edges
    Loaded:   2 nodes, 1 edges
    Node labels match: True
    Edge types match: True

``` python
# Test from_dict
ctx_dict = context.to_dict()
loaded_from_dict = GraphContext.from_dict(ctx_dict)

print(f"From dict: {len(loaded_from_dict.nodes)} nodes, {len(loaded_from_dict.edges)} edges")
```

    From dict: 2 nodes, 1 edges

## GraphQuery

A standardized query object that can represent:

- Raw query strings (SQL, Cypher, etc.)
- Structured search parameters

The `depth` parameter is used for neighborhood traversals.

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/core.py#L135"
target="_blank" style="float:right; font-size:smaller">source</a>

### GraphQuery

``` python

def GraphQuery(
    query:str, parameters:Dict=<factory>, limit:int=100, depth:int=1
)->None:

```

*A standardized query object for graph operations.*

``` python
# Test GraphQuery with SQL-style query
sql_query = GraphQuery(
    query="SELECT * FROM nodes WHERE label = :label",
    parameters={"label": "Person"},
    limit=50
)
print(f"SQL Query: {sql_query}")
print(f"As dict: {sql_query.to_dict()}")
```

    SQL Query: GraphQuery(query='SELECT * FROM nodes WHERE label = :label', parameters={'label': 'Person'}, limit=50, depth=1)
    As dict: {'query': 'SELECT * FROM nodes WHERE label = :label', 'parameters': {'label': 'Person'}, 'limit': 50, 'depth': 1}

``` python
# Test GraphQuery for neighborhood traversal
traversal_query = GraphQuery(
    query="NEIGHBORS",
    parameters={"start_node": person_id},
    depth=2,
    limit=100
)
print(f"Traversal Query: {traversal_query}")
```

    Traversal Query: GraphQuery(query='NEIGHBORS', parameters={'start_node': '74bd93af-afe3-4bd1-b2f8-628808e4c063'}, limit=100, depth=2)

``` python
# Test minimal query
simple = GraphQuery(query="SELECT * FROM nodes")
print(f"Simple query defaults: limit={simple.limit}, depth={simple.depth}")
```

    Simple query defaults: limit=100, depth=1
