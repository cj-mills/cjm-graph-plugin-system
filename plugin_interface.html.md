# Graph Plugin Interface


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## GraphPlugin

Abstract base class for all Context Graph plugins. Provides a
standardized interface for:

- **CRUD Operations**: Create, read, update, delete nodes and edges
- **Traversal**: Get neighborhood context around a node
- **Querying**: Execute raw queries or structured searches
- **Lifecycle**: Import/export graph data, introspect schema

**Usage via RemotePluginProxy / JobQueue:**

The `execute()` method is the main entry point when called via HTTP
proxy. It dispatches to the appropriate method based on the `action`
parameter:

``` python
# Via JobQueue
job_id = await queue.submit(
    "cjm-graph-plugin-sqlite",
    action="add_nodes",
    nodes=[node1.to_dict(), node2.to_dict()]
)

# Via PluginManager
result = manager.execute_plugin(
    "cjm-graph-plugin-sqlite",
    action="get_context",
    node_id="abc-123",
    depth=2
)
```

**Available Actions:**

<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 34%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr>
<th>Action</th>
<th>Description</th>
<th>Required kwargs</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>get_schema</code></td>
<td>Get graph ontology (default)</td>
<td>-</td>
</tr>
<tr>
<td><code>add_nodes</code></td>
<td>Create nodes</td>
<td><code>nodes</code> (list of dicts)</td>
</tr>
<tr>
<td><code>add_edges</code></td>
<td>Create edges</td>
<td><code>edges</code> (list of dicts)</td>
</tr>
<tr>
<td><code>get_node</code></td>
<td>Get single node</td>
<td><code>node_id</code></td>
</tr>
<tr>
<td><code>get_edge</code></td>
<td>Get single edge</td>
<td><code>edge_id</code></td>
</tr>
<tr>
<td><code>get_context</code></td>
<td>Neighborhood traversal</td>
<td><code>node_id</code>, optional: <code>depth</code>,
<code>filter_labels</code></td>
</tr>
<tr>
<td><code>find_nodes_by_source</code></td>
<td>Find by external reference</td>
<td><code>source_ref</code> (dict)</td>
</tr>
<tr>
<td><code>find_nodes_by_label</code></td>
<td>Find by label</td>
<td><code>label</code>, optional: <code>limit</code></td>
</tr>
<tr>
<td><code>update_node</code></td>
<td>Update node properties</td>
<td><code>node_id</code>, <code>properties</code></td>
</tr>
<tr>
<td><code>update_edge</code></td>
<td>Update edge properties</td>
<td><code>edge_id</code>, <code>properties</code></td>
</tr>
<tr>
<td><code>delete_nodes</code></td>
<td>Delete nodes</td>
<td><code>node_ids</code>, optional: <code>cascade</code></td>
</tr>
<tr>
<td><code>delete_edges</code></td>
<td>Delete edges</td>
<td><code>edge_ids</code></td>
</tr>
<tr>
<td><code>import_graph</code></td>
<td>Bulk import</td>
<td><code>graph_data</code> (dict), optional:
<code>merge_strategy</code></td>
</tr>
<tr>
<td><code>export_graph</code></td>
<td>Bulk export</td>
<td>optional: <code>filter_query</code></td>
</tr>
<tr>
<td><code>query</code></td>
<td>Raw query execution</td>
<td><code>query</code> (string or dict)</td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/plugin_interface.py#L23"
target="_blank" style="float:right; font-size:smaller">source</a>

### GraphPlugin

``` python

def GraphPlugin(
    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD
):

```

*Abstract base class for all Context Graph plugins.*

## Interface Documentation

### CREATE Operations

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/plugin_interface.py#L51"
target="_blank" style="float:right; font-size:smaller">source</a>

### GraphPlugin.add_nodes

``` python

def add_nodes(
    nodes:List, # Nodes to create
)->List: # Created node IDs

```

*Bulk create nodes.*

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/plugin_interface.py#L59"
target="_blank" style="float:right; font-size:smaller">source</a>

### GraphPlugin.add_edges

``` python

def add_edges(
    edges:List, # Edges to create
)->List: # Created edge IDs

```

*Bulk create edges.*

### READ Operations

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/plugin_interface.py#L71"
target="_blank" style="float:right; font-size:smaller">source</a>

### GraphPlugin.get_node

``` python

def get_node(
    node_id:str, # UUID of node to retrieve
)->Optional: # Node or None if not found

```

*Get a single node by ID.*

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/plugin_interface.py#L79"
target="_blank" style="float:right; font-size:smaller">source</a>

### GraphPlugin.get_edge

``` python

def get_edge(
    edge_id:str, # UUID of edge to retrieve
)->Optional: # Edge or None if not found

```

*Get a single edge by ID.*

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/plugin_interface.py#L87"
target="_blank" style="float:right; font-size:smaller">source</a>

### GraphPlugin.get_context

``` python

def get_context(
    node_id:str, # Starting node UUID
    depth:int=1, # Traversal depth (1 = immediate neighbors)
    filter_labels:Optional=None, # Only include nodes with these labels
)->GraphContext: # Subgraph containing node and its neighborhood

```

*Get the neighborhood of a specific node.*

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/plugin_interface.py#L97"
target="_blank" style="float:right; font-size:smaller">source</a>

### GraphPlugin.find_nodes_by_source

``` python

def find_nodes_by_source(
    source_ref:SourceRef, # External resource reference
)->List: # Nodes attached to this source

```

*Find all nodes linked to a specific external resource.*

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/plugin_interface.py#L105"
target="_blank" style="float:right; font-size:smaller">source</a>

### GraphPlugin.find_nodes_by_label

``` python

def find_nodes_by_label(
    label:str, # Node label to search for
    limit:int=100, # Max results
)->List: # Matching nodes

```

*Find nodes by label.*

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/plugin_interface.py#L33"
target="_blank" style="float:right; font-size:smaller">source</a>

### GraphPlugin.execute

``` python

def execute(
    action:str='get_schema', # Action to perform (see docstring for available actions)
    kwargs:VAR_KEYWORD
)->Dict: # JSON-serializable result

```

*Execute a graph operation. This is the main entry point for
RemotePluginProxy.*

Dispatches to the appropriate method based on `action` parameter. All
return values are JSON-serializable dictionaries for HTTP transport.

### UPDATE Operations

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/plugin_interface.py#L118"
target="_blank" style="float:right; font-size:smaller">source</a>

### GraphPlugin.update_node

``` python

def update_node(
    node_id:str, # UUID of node to update
    properties:Dict, # Properties to merge/update
)->bool: # True if successful

```

*Partial update of node properties.*

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/plugin_interface.py#L127"
target="_blank" style="float:right; font-size:smaller">source</a>

### GraphPlugin.update_edge

``` python

def update_edge(
    edge_id:str, # UUID of edge to update
    properties:Dict, # Properties to merge/update
)->bool: # True if successful

```

*Partial update of edge properties.*

### DELETE Operations

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/plugin_interface.py#L140"
target="_blank" style="float:right; font-size:smaller">source</a>

### GraphPlugin.delete_nodes

``` python

def delete_nodes(
    node_ids:List, # UUIDs of nodes to delete
    cascade:bool=True, # Also delete connected edges
)->int: # Number of nodes deleted

```

*Delete nodes (and optionally connected edges).*

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/plugin_interface.py#L149"
target="_blank" style="float:right; font-size:smaller">source</a>

### GraphPlugin.delete_edges

``` python

def delete_edges(
    edge_ids:List, # UUIDs of edges to delete
)->int: # Number of edges deleted

```

*Delete edges.*

### LIFECYCLE Operations

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/plugin_interface.py#L161"
target="_blank" style="float:right; font-size:smaller">source</a>

### GraphPlugin.get_schema

``` python

def get_schema(
    
)->Dict: # Graph schema/ontology

```

*Return the current ontology/schema of the graph.*

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/plugin_interface.py#L166"
target="_blank" style="float:right; font-size:smaller">source</a>

### GraphPlugin.import_graph

``` python

def import_graph(
    graph_data:GraphContext, # Data to import
    merge_strategy:str='overwrite', # "overwrite", "skip", or "merge"
)->Dict: # Import statistics {nodes_created, edges_created, ...}

```

*Bulk import a GraphContext (e.g., from backup or another plugin).*

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-graph-plugin-system/blob/main/cjm_graph_plugin_system/plugin_interface.py#L175"
target="_blank" style="float:right; font-size:smaller">source</a>

### GraphPlugin.export_graph

``` python

def export_graph(
    filter_query:Optional=None, # Optional filter
)->GraphContext: # Exported subgraph or full graph

```

*Export the entire graph or a filtered subset.*

## Example Schema Return Value

The `get_schema()` method returns information about the current graph
ontology:

``` python
{
    "node_labels": ["Person", "Concept", "Correction", "Event"],
    "edge_types": ["MENTIONS", "CORRECTS", "AUTHORED_BY", "RELATED_TO"],
    "counts": {
        "nodes": {"Person": 12, "Concept": 45, "Correction": 3},
        "edges": {"MENTIONS": 78, "CORRECTS": 5}
    },
    "properties": {
        "Person": ["name", "role", "confidence"],
        "Concept": ["name", "definition", "aliases"]
    }
}
```

This is useful for UIs that need to know available labels and types for
filtering/querying.

## Example Implementation

A minimal in-memory implementation demonstrating the interface:

``` python
class InMemoryGraphPlugin(GraphPlugin):
    """Simple in-memory implementation for testing."""

    def __init__(self):
        self._nodes: Dict[str, GraphNode] = {}
        self._edges: Dict[str, GraphEdge] = {}
        self._config: Dict[str, Any] = {}

    @property
    def name(self) -> str:
        return "in-memory-graph"

    @property
    def version(self) -> str:
        return "1.0.0"

    def initialize(self, config: Optional[Dict[str, Any]] = None) -> None:
        self._config = config or {}

    def get_config_schema(self) -> Dict[str, Any]:
        return {"type": "object", "properties": {}}

    def get_current_config(self) -> Dict[str, Any]:
        return self._config

    def cleanup(self) -> None:
        self._nodes.clear()
        self._edges.clear()

    # -------------------------------------------------------------------------
    # EXECUTE - Main dispatcher for RemotePluginProxy
    # -------------------------------------------------------------------------

    def execute(self, action: str = "get_schema", **kwargs) -> Dict[str, Any]:
        """Dispatch to appropriate method based on action."""
        
        if action == "get_schema":
            return self.get_schema()
        
        elif action == "add_nodes":
            # Convert dicts to GraphNode objects
            nodes = [GraphNode(**n) if isinstance(n, dict) else n for n in kwargs.get("nodes", [])]
            ids = self.add_nodes(nodes)
            return {"created_ids": ids, "count": len(ids)}
        
        elif action == "add_edges":
            edges = [GraphEdge(**e) if isinstance(e, dict) else e for e in kwargs.get("edges", [])]
            ids = self.add_edges(edges)
            return {"created_ids": ids, "count": len(ids)}
        
        elif action == "get_node":
            node = self.get_node(kwargs["node_id"])
            return {"node": node.to_dict() if node else None}
        
        elif action == "get_edge":
            edge = self.get_edge(kwargs["edge_id"])
            return {"edge": edge.to_dict() if edge else None}
        
        elif action == "get_context":
            ctx = self.get_context(
                kwargs["node_id"],
                depth=kwargs.get("depth", 1),
                filter_labels=kwargs.get("filter_labels")
            )
            return ctx.to_dict()
        
        elif action == "find_nodes_by_source":
            ref_data = kwargs["source_ref"]
            ref = SourceRef(**ref_data) if isinstance(ref_data, dict) else ref_data
            nodes = self.find_nodes_by_source(ref)
            return {"nodes": [n.to_dict() for n in nodes], "count": len(nodes)}
        
        elif action == "find_nodes_by_label":
            nodes = self.find_nodes_by_label(kwargs["label"], limit=kwargs.get("limit", 100))
            return {"nodes": [n.to_dict() for n in nodes], "count": len(nodes)}
        
        elif action == "update_node":
            success = self.update_node(kwargs["node_id"], kwargs["properties"])
            return {"success": success}
        
        elif action == "update_edge":
            success = self.update_edge(kwargs["edge_id"], kwargs["properties"])
            return {"success": success}
        
        elif action == "delete_nodes":
            count = self.delete_nodes(kwargs["node_ids"], cascade=kwargs.get("cascade", True))
            return {"deleted_count": count}
        
        elif action == "delete_edges":
            count = self.delete_edges(kwargs["edge_ids"])
            return {"deleted_count": count}
        
        elif action == "import_graph":
            graph_data = kwargs["graph_data"]
            if isinstance(graph_data, dict):
                graph_data = GraphContext.from_dict(graph_data)
            stats = self.import_graph(graph_data, merge_strategy=kwargs.get("merge_strategy", "overwrite"))
            return stats
        
        elif action == "export_graph":
            ctx = self.export_graph(filter_query=kwargs.get("filter_query"))
            return ctx.to_dict()
        
        else:
            raise ValueError(f"Unknown action: {action}")

    # -------------------------------------------------------------------------
    # CREATE
    # -------------------------------------------------------------------------

    def add_nodes(self, nodes: List[GraphNode]) -> List[str]:
        ids = []
        for node in nodes:
            self._nodes[node.id] = node
            ids.append(node.id)
        return ids

    def add_edges(self, edges: List[GraphEdge]) -> List[str]:
        ids = []
        for edge in edges:
            self._edges[edge.id] = edge
            ids.append(edge.id)
        return ids

    # -------------------------------------------------------------------------
    # READ
    # -------------------------------------------------------------------------

    def get_node(self, node_id: str) -> Optional[GraphNode]:
        return self._nodes.get(node_id)

    def get_edge(self, edge_id: str) -> Optional[GraphEdge]:
        return self._edges.get(edge_id)

    def get_context(self, node_id: str, depth: int = 1, filter_labels: Optional[List[str]] = None) -> GraphContext:
        nodes = []
        edges = []
        
        if node_id in self._nodes:
            nodes.append(self._nodes[node_id])
            
        for edge in self._edges.values():
            if edge.source_id == node_id or edge.target_id == node_id:
                edges.append(edge)
                other_id = edge.target_id if edge.source_id == node_id else edge.source_id
                if other_id in self._nodes:
                    neighbor = self._nodes[other_id]
                    if filter_labels is None or neighbor.label in filter_labels:
                        if neighbor not in nodes:
                            nodes.append(neighbor)
                            
        return GraphContext(nodes=nodes, edges=edges, metadata={"depth": depth})

    def find_nodes_by_source(self, source_ref: SourceRef) -> List[GraphNode]:
        results = []
        for node in self._nodes.values():
            for src in node.sources:
                if (src.plugin_name == source_ref.plugin_name and
                    src.table_name == source_ref.table_name and
                    src.row_id == source_ref.row_id):
                    results.append(node)
                    break
        return results

    def find_nodes_by_label(self, label: str, limit: int = 100) -> List[GraphNode]:
        return [n for n in self._nodes.values() if n.label == label][:limit]

    # -------------------------------------------------------------------------
    # UPDATE
    # -------------------------------------------------------------------------

    def update_node(self, node_id: str, properties: Dict[str, Any]) -> bool:
        if node_id not in self._nodes:
            return False
        self._nodes[node_id].properties.update(properties)
        return True

    def update_edge(self, edge_id: str, properties: Dict[str, Any]) -> bool:
        if edge_id not in self._edges:
            return False
        self._edges[edge_id].properties.update(properties)
        return True

    # -------------------------------------------------------------------------
    # DELETE
    # -------------------------------------------------------------------------

    def delete_nodes(self, node_ids: List[str], cascade: bool = True) -> int:
        count = 0
        for nid in node_ids:
            if nid in self._nodes:
                del self._nodes[nid]
                count += 1
                if cascade:
                    to_remove = [eid for eid, e in self._edges.items()
                                 if e.source_id == nid or e.target_id == nid]
                    for eid in to_remove:
                        del self._edges[eid]
        return count

    def delete_edges(self, edge_ids: List[str]) -> int:
        count = 0
        for eid in edge_ids:
            if eid in self._edges:
                del self._edges[eid]
                count += 1
        return count

    # -------------------------------------------------------------------------
    # LIFECYCLE
    # -------------------------------------------------------------------------

    def get_schema(self) -> Dict[str, Any]:
        labels = set(n.label for n in self._nodes.values())
        types = set(e.relation_type for e in self._edges.values())
        return {
            "node_labels": list(labels),
            "edge_types": list(types),
            "counts": {
                "nodes": len(self._nodes),
                "edges": len(self._edges)
            }
        }

    def import_graph(self, graph_data: GraphContext, merge_strategy: str = "overwrite") -> Dict[str, int]:
        nodes_created = 0
        edges_created = 0
        
        for node in graph_data.nodes:
            if merge_strategy == "skip" and node.id in self._nodes:
                continue
            self._nodes[node.id] = node
            nodes_created += 1
            
        for edge in graph_data.edges:
            if merge_strategy == "skip" and edge.id in self._edges:
                continue
            self._edges[edge.id] = edge
            edges_created += 1
            
        return {"nodes_created": nodes_created, "edges_created": edges_created}

    def export_graph(self, filter_query: Optional[GraphQuery] = None) -> GraphContext:
        return GraphContext(
            nodes=list(self._nodes.values()),
            edges=list(self._edges.values()),
            metadata={"exported_at": "now"}
        )
```

``` python
import uuid

# Test the example plugin
plugin = InMemoryGraphPlugin()
plugin.initialize()

print(f"Plugin: {plugin.name} v{plugin.version}")
```

    Plugin: in-memory-graph v1.0.0

``` python
# Create some nodes
alice_id = str(uuid.uuid4())
bob_id = str(uuid.uuid4())
ml_id = str(uuid.uuid4())

nodes = [
    GraphNode(id=alice_id, label="Person", properties={"name": "Alice"}),
    GraphNode(id=bob_id, label="Person", properties={"name": "Bob"}),
    GraphNode(id=ml_id, label="Concept", properties={"name": "Machine Learning"})
]

created_ids = plugin.add_nodes(nodes)
print(f"Created {len(created_ids)} nodes")
```

    Created 3 nodes

``` python
# Create edges
edges = [
    GraphEdge(id=str(uuid.uuid4()), source_id=alice_id, target_id=ml_id, relation_type="MENTIONS"),
    GraphEdge(id=str(uuid.uuid4()), source_id=bob_id, target_id=ml_id, relation_type="MENTIONS"),
    GraphEdge(id=str(uuid.uuid4()), source_id=alice_id, target_id=bob_id, relation_type="KNOWS")
]

created_ids = plugin.add_edges(edges)
print(f"Created {len(created_ids)} edges")
```

    Created 3 edges

``` python
# Test get_context (neighborhood traversal)
context = plugin.get_context(alice_id, depth=1)
print(f"Alice's neighborhood: {len(context.nodes)} nodes, {len(context.edges)} edges")
print(f"Neighbors: {[n.properties.get('name', n.label) for n in context.nodes]}")
```

    Alice's neighborhood: 3 nodes, 2 edges
    Neighbors: ['Alice', 'Machine Learning', 'Bob']

``` python
# Test find_nodes_by_label
people = plugin.find_nodes_by_label("Person")
print(f"People: {[p.properties['name'] for p in people]}")
```

    People: ['Alice', 'Bob']

``` python
# Test get_schema
schema = plugin.get_schema()
print(f"Schema: {schema}")
```

    Schema: {'node_labels': ['Person', 'Concept'], 'edge_types': ['KNOWS', 'MENTIONS'], 'counts': {'nodes': 3, 'edges': 3}}

``` python
# Test update_node
plugin.update_node(alice_id, {"role": "speaker", "confidence": 0.95})
alice = plugin.get_node(alice_id)
print(f"Updated Alice: {alice.properties}")
```

    Updated Alice: {'name': 'Alice', 'role': 'speaker', 'confidence': 0.95}

``` python
# Test export/import
exported = plugin.export_graph()
print(f"Exported: {len(exported.nodes)} nodes, {len(exported.edges)} edges")

# Import into a new plugin instance
new_plugin = InMemoryGraphPlugin()
new_plugin.initialize()
stats = new_plugin.import_graph(exported)
print(f"Import stats: {stats}")
```

    Exported: 3 nodes, 3 edges
    Import stats: {'nodes_created': 3, 'edges_created': 3}

``` python
# Test delete with cascade
deleted = plugin.delete_nodes([alice_id], cascade=True)
print(f"Deleted {deleted} node(s)")
print(f"Remaining: {plugin.get_schema()}")
```

    Deleted 1 node(s)
    Remaining: {'node_labels': ['Person', 'Concept'], 'edge_types': ['MENTIONS'], 'counts': {'nodes': 2, 'edges': 1}}

``` python
# Cleanup
plugin.cleanup()
new_plugin.cleanup()
```
