[
  {
    "objectID": "plugin_interface.html",
    "href": "plugin_interface.html",
    "title": "Graph Plugin Interface",
    "section": "",
    "text": "Abstract base class for all Context Graph plugins. Provides a standardized interface for:\n\nCRUD Operations: Create, read, update, delete nodes and edges\nTraversal: Get neighborhood context around a node\nQuerying: Execute raw queries or structured searches\nLifecycle: Import/export graph data, introspect schema\n\nUsage via RemotePluginProxy / JobQueue:\nThe execute() method is the main entry point when called via HTTP proxy. It dispatches to the appropriate method based on the action parameter:\n# Via JobQueue\njob_id = await queue.submit(\n    \"cjm-graph-plugin-sqlite\",\n    action=\"add_nodes\",\n    nodes=[node1.to_dict(), node2.to_dict()]\n)\n\n# Via PluginManager\nresult = manager.execute_plugin(\n    \"cjm-graph-plugin-sqlite\",\n    action=\"get_context\",\n    node_id=\"abc-123\",\n    depth=2\n)\nAvailable Actions:\n\n\n\n\n\n\n\n\nAction\nDescription\nRequired kwargs\n\n\n\n\nget_schema\nGet graph ontology (default)\n-\n\n\nadd_nodes\nCreate nodes\nnodes (list of dicts)\n\n\nadd_edges\nCreate edges\nedges (list of dicts)\n\n\nget_node\nGet single node\nnode_id\n\n\nget_edge\nGet single edge\nedge_id\n\n\nget_context\nNeighborhood traversal\nnode_id, optional: depth, filter_labels\n\n\nfind_nodes_by_source\nFind by external reference\nsource_ref (dict)\n\n\nfind_nodes_by_label\nFind by label\nlabel, optional: limit\n\n\nupdate_node\nUpdate node properties\nnode_id, properties\n\n\nupdate_edge\nUpdate edge properties\nedge_id, properties\n\n\ndelete_nodes\nDelete nodes\nnode_ids, optional: cascade\n\n\ndelete_edges\nDelete edges\nedge_ids\n\n\nimport_graph\nBulk import\ngraph_data (dict), optional: merge_strategy\n\n\nexport_graph\nBulk export\noptional: filter_query\n\n\nquery\nRaw query execution\nquery (string or dict)\n\n\n\n\nsource\n\n\n\ndef GraphPlugin(\n    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD\n):\n\nAbstract base class for all Context Graph plugins.",
    "crumbs": [
      "Graph Plugin Interface"
    ]
  },
  {
    "objectID": "plugin_interface.html#graphplugin",
    "href": "plugin_interface.html#graphplugin",
    "title": "Graph Plugin Interface",
    "section": "",
    "text": "Abstract base class for all Context Graph plugins. Provides a standardized interface for:\n\nCRUD Operations: Create, read, update, delete nodes and edges\nTraversal: Get neighborhood context around a node\nQuerying: Execute raw queries or structured searches\nLifecycle: Import/export graph data, introspect schema\n\nUsage via RemotePluginProxy / JobQueue:\nThe execute() method is the main entry point when called via HTTP proxy. It dispatches to the appropriate method based on the action parameter:\n# Via JobQueue\njob_id = await queue.submit(\n    \"cjm-graph-plugin-sqlite\",\n    action=\"add_nodes\",\n    nodes=[node1.to_dict(), node2.to_dict()]\n)\n\n# Via PluginManager\nresult = manager.execute_plugin(\n    \"cjm-graph-plugin-sqlite\",\n    action=\"get_context\",\n    node_id=\"abc-123\",\n    depth=2\n)\nAvailable Actions:\n\n\n\n\n\n\n\n\nAction\nDescription\nRequired kwargs\n\n\n\n\nget_schema\nGet graph ontology (default)\n-\n\n\nadd_nodes\nCreate nodes\nnodes (list of dicts)\n\n\nadd_edges\nCreate edges\nedges (list of dicts)\n\n\nget_node\nGet single node\nnode_id\n\n\nget_edge\nGet single edge\nedge_id\n\n\nget_context\nNeighborhood traversal\nnode_id, optional: depth, filter_labels\n\n\nfind_nodes_by_source\nFind by external reference\nsource_ref (dict)\n\n\nfind_nodes_by_label\nFind by label\nlabel, optional: limit\n\n\nupdate_node\nUpdate node properties\nnode_id, properties\n\n\nupdate_edge\nUpdate edge properties\nedge_id, properties\n\n\ndelete_nodes\nDelete nodes\nnode_ids, optional: cascade\n\n\ndelete_edges\nDelete edges\nedge_ids\n\n\nimport_graph\nBulk import\ngraph_data (dict), optional: merge_strategy\n\n\nexport_graph\nBulk export\noptional: filter_query\n\n\nquery\nRaw query execution\nquery (string or dict)\n\n\n\n\nsource\n\n\n\ndef GraphPlugin(\n    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD\n):\n\nAbstract base class for all Context Graph plugins.",
    "crumbs": [
      "Graph Plugin Interface"
    ]
  },
  {
    "objectID": "plugin_interface.html#interface-documentation",
    "href": "plugin_interface.html#interface-documentation",
    "title": "Graph Plugin Interface",
    "section": "Interface Documentation",
    "text": "Interface Documentation\n\nCREATE Operations\n\nsource\n\n\nGraphPlugin.add_nodes\n\ndef add_nodes(\n    nodes:List, # Nodes to create\n)-&gt;List: # Created node IDs\n\nBulk create nodes.\n\nsource\n\n\nGraphPlugin.add_edges\n\ndef add_edges(\n    edges:List, # Edges to create\n)-&gt;List: # Created edge IDs\n\nBulk create edges.\n\n\nREAD Operations\n\nsource\n\n\nGraphPlugin.get_node\n\ndef get_node(\n    node_id:str, # UUID of node to retrieve\n)-&gt;Optional: # Node or None if not found\n\nGet a single node by ID.\n\nsource\n\n\nGraphPlugin.get_edge\n\ndef get_edge(\n    edge_id:str, # UUID of edge to retrieve\n)-&gt;Optional: # Edge or None if not found\n\nGet a single edge by ID.\n\nsource\n\n\nGraphPlugin.get_context\n\ndef get_context(\n    node_id:str, # Starting node UUID\n    depth:int=1, # Traversal depth (1 = immediate neighbors)\n    filter_labels:Optional=None, # Only include nodes with these labels\n)-&gt;GraphContext: # Subgraph containing node and its neighborhood\n\nGet the neighborhood of a specific node.\n\nsource\n\n\nGraphPlugin.find_nodes_by_source\n\ndef find_nodes_by_source(\n    source_ref:SourceRef, # External resource reference\n)-&gt;List: # Nodes attached to this source\n\nFind all nodes linked to a specific external resource.\n\nsource\n\n\nGraphPlugin.find_nodes_by_label\n\ndef find_nodes_by_label(\n    label:str, # Node label to search for\n    limit:int=100, # Max results\n)-&gt;List: # Matching nodes\n\nFind nodes by label.\n\nsource\n\n\nGraphPlugin.execute\n\ndef execute(\n    action:str='get_schema', # Action to perform (see docstring for available actions)\n    kwargs:VAR_KEYWORD\n)-&gt;Dict: # JSON-serializable result\n\nExecute a graph operation. This is the main entry point for RemotePluginProxy.\nDispatches to the appropriate method based on action parameter. All return values are JSON-serializable dictionaries for HTTP transport.\n\n\nUPDATE Operations\n\nsource\n\n\nGraphPlugin.update_node\n\ndef update_node(\n    node_id:str, # UUID of node to update\n    properties:Dict, # Properties to merge/update\n)-&gt;bool: # True if successful\n\nPartial update of node properties.\n\nsource\n\n\nGraphPlugin.update_edge\n\ndef update_edge(\n    edge_id:str, # UUID of edge to update\n    properties:Dict, # Properties to merge/update\n)-&gt;bool: # True if successful\n\nPartial update of edge properties.\n\n\nDELETE Operations\n\nsource\n\n\nGraphPlugin.delete_nodes\n\ndef delete_nodes(\n    node_ids:List, # UUIDs of nodes to delete\n    cascade:bool=True, # Also delete connected edges\n)-&gt;int: # Number of nodes deleted\n\nDelete nodes (and optionally connected edges).\n\nsource\n\n\nGraphPlugin.delete_edges\n\ndef delete_edges(\n    edge_ids:List, # UUIDs of edges to delete\n)-&gt;int: # Number of edges deleted\n\nDelete edges.\n\n\nLIFECYCLE Operations\n\nsource\n\n\nGraphPlugin.get_schema\n\ndef get_schema(\n    \n)-&gt;Dict: # Graph schema/ontology\n\nReturn the current ontology/schema of the graph.\n\nsource\n\n\nGraphPlugin.import_graph\n\ndef import_graph(\n    graph_data:GraphContext, # Data to import\n    merge_strategy:str='overwrite', # \"overwrite\", \"skip\", or \"merge\"\n)-&gt;Dict: # Import statistics {nodes_created, edges_created, ...}\n\nBulk import a GraphContext (e.g., from backup or another plugin).\n\nsource\n\n\nGraphPlugin.export_graph\n\ndef export_graph(\n    filter_query:Optional=None, # Optional filter\n)-&gt;GraphContext: # Exported subgraph or full graph\n\nExport the entire graph or a filtered subset.",
    "crumbs": [
      "Graph Plugin Interface"
    ]
  },
  {
    "objectID": "plugin_interface.html#example-schema-return-value",
    "href": "plugin_interface.html#example-schema-return-value",
    "title": "Graph Plugin Interface",
    "section": "Example Schema Return Value",
    "text": "Example Schema Return Value\nThe get_schema() method returns information about the current graph ontology:\n{\n    \"node_labels\": [\"Person\", \"Concept\", \"Correction\", \"Event\"],\n    \"edge_types\": [\"MENTIONS\", \"CORRECTS\", \"AUTHORED_BY\", \"RELATED_TO\"],\n    \"counts\": {\n        \"nodes\": {\"Person\": 12, \"Concept\": 45, \"Correction\": 3},\n        \"edges\": {\"MENTIONS\": 78, \"CORRECTS\": 5}\n    },\n    \"properties\": {\n        \"Person\": [\"name\", \"role\", \"confidence\"],\n        \"Concept\": [\"name\", \"definition\", \"aliases\"]\n    }\n}\nThis is useful for UIs that need to know available labels and types for filtering/querying.",
    "crumbs": [
      "Graph Plugin Interface"
    ]
  },
  {
    "objectID": "plugin_interface.html#example-implementation",
    "href": "plugin_interface.html#example-implementation",
    "title": "Graph Plugin Interface",
    "section": "Example Implementation",
    "text": "Example Implementation\nA minimal in-memory implementation demonstrating the interface:\n\nclass InMemoryGraphPlugin(GraphPlugin):\n    \"\"\"Simple in-memory implementation for testing.\"\"\"\n\n    def __init__(self):\n        self._nodes: Dict[str, GraphNode] = {}\n        self._edges: Dict[str, GraphEdge] = {}\n        self._config: Dict[str, Any] = {}\n\n    @property\n    def name(self) -&gt; str:\n        return \"in-memory-graph\"\n\n    @property\n    def version(self) -&gt; str:\n        return \"1.0.0\"\n\n    def initialize(self, config: Optional[Dict[str, Any]] = None) -&gt; None:\n        self._config = config or {}\n\n    def get_config_schema(self) -&gt; Dict[str, Any]:\n        return {\"type\": \"object\", \"properties\": {}}\n\n    def get_current_config(self) -&gt; Dict[str, Any]:\n        return self._config\n\n    def cleanup(self) -&gt; None:\n        self._nodes.clear()\n        self._edges.clear()\n\n    # -------------------------------------------------------------------------\n    # EXECUTE - Main dispatcher for RemotePluginProxy\n    # -------------------------------------------------------------------------\n\n    def execute(self, action: str = \"get_schema\", **kwargs) -&gt; Dict[str, Any]:\n        \"\"\"Dispatch to appropriate method based on action.\"\"\"\n        \n        if action == \"get_schema\":\n            return self.get_schema()\n        \n        elif action == \"add_nodes\":\n            # Convert dicts to GraphNode objects\n            nodes = [GraphNode(**n) if isinstance(n, dict) else n for n in kwargs.get(\"nodes\", [])]\n            ids = self.add_nodes(nodes)\n            return {\"created_ids\": ids, \"count\": len(ids)}\n        \n        elif action == \"add_edges\":\n            edges = [GraphEdge(**e) if isinstance(e, dict) else e for e in kwargs.get(\"edges\", [])]\n            ids = self.add_edges(edges)\n            return {\"created_ids\": ids, \"count\": len(ids)}\n        \n        elif action == \"get_node\":\n            node = self.get_node(kwargs[\"node_id\"])\n            return {\"node\": node.to_dict() if node else None}\n        \n        elif action == \"get_edge\":\n            edge = self.get_edge(kwargs[\"edge_id\"])\n            return {\"edge\": edge.to_dict() if edge else None}\n        \n        elif action == \"get_context\":\n            ctx = self.get_context(\n                kwargs[\"node_id\"],\n                depth=kwargs.get(\"depth\", 1),\n                filter_labels=kwargs.get(\"filter_labels\")\n            )\n            return ctx.to_dict()\n        \n        elif action == \"find_nodes_by_source\":\n            ref_data = kwargs[\"source_ref\"]\n            ref = SourceRef(**ref_data) if isinstance(ref_data, dict) else ref_data\n            nodes = self.find_nodes_by_source(ref)\n            return {\"nodes\": [n.to_dict() for n in nodes], \"count\": len(nodes)}\n        \n        elif action == \"find_nodes_by_label\":\n            nodes = self.find_nodes_by_label(kwargs[\"label\"], limit=kwargs.get(\"limit\", 100))\n            return {\"nodes\": [n.to_dict() for n in nodes], \"count\": len(nodes)}\n        \n        elif action == \"update_node\":\n            success = self.update_node(kwargs[\"node_id\"], kwargs[\"properties\"])\n            return {\"success\": success}\n        \n        elif action == \"update_edge\":\n            success = self.update_edge(kwargs[\"edge_id\"], kwargs[\"properties\"])\n            return {\"success\": success}\n        \n        elif action == \"delete_nodes\":\n            count = self.delete_nodes(kwargs[\"node_ids\"], cascade=kwargs.get(\"cascade\", True))\n            return {\"deleted_count\": count}\n        \n        elif action == \"delete_edges\":\n            count = self.delete_edges(kwargs[\"edge_ids\"])\n            return {\"deleted_count\": count}\n        \n        elif action == \"import_graph\":\n            graph_data = kwargs[\"graph_data\"]\n            if isinstance(graph_data, dict):\n                graph_data = GraphContext.from_dict(graph_data)\n            stats = self.import_graph(graph_data, merge_strategy=kwargs.get(\"merge_strategy\", \"overwrite\"))\n            return stats\n        \n        elif action == \"export_graph\":\n            ctx = self.export_graph(filter_query=kwargs.get(\"filter_query\"))\n            return ctx.to_dict()\n        \n        else:\n            raise ValueError(f\"Unknown action: {action}\")\n\n    # -------------------------------------------------------------------------\n    # CREATE\n    # -------------------------------------------------------------------------\n\n    def add_nodes(self, nodes: List[GraphNode]) -&gt; List[str]:\n        ids = []\n        for node in nodes:\n            self._nodes[node.id] = node\n            ids.append(node.id)\n        return ids\n\n    def add_edges(self, edges: List[GraphEdge]) -&gt; List[str]:\n        ids = []\n        for edge in edges:\n            self._edges[edge.id] = edge\n            ids.append(edge.id)\n        return ids\n\n    # -------------------------------------------------------------------------\n    # READ\n    # -------------------------------------------------------------------------\n\n    def get_node(self, node_id: str) -&gt; Optional[GraphNode]:\n        return self._nodes.get(node_id)\n\n    def get_edge(self, edge_id: str) -&gt; Optional[GraphEdge]:\n        return self._edges.get(edge_id)\n\n    def get_context(self, node_id: str, depth: int = 1, filter_labels: Optional[List[str]] = None) -&gt; GraphContext:\n        nodes = []\n        edges = []\n        \n        if node_id in self._nodes:\n            nodes.append(self._nodes[node_id])\n            \n        for edge in self._edges.values():\n            if edge.source_id == node_id or edge.target_id == node_id:\n                edges.append(edge)\n                other_id = edge.target_id if edge.source_id == node_id else edge.source_id\n                if other_id in self._nodes:\n                    neighbor = self._nodes[other_id]\n                    if filter_labels is None or neighbor.label in filter_labels:\n                        if neighbor not in nodes:\n                            nodes.append(neighbor)\n                            \n        return GraphContext(nodes=nodes, edges=edges, metadata={\"depth\": depth})\n\n    def find_nodes_by_source(self, source_ref: SourceRef) -&gt; List[GraphNode]:\n        results = []\n        for node in self._nodes.values():\n            for src in node.sources:\n                if (src.plugin_name == source_ref.plugin_name and\n                    src.table_name == source_ref.table_name and\n                    src.row_id == source_ref.row_id):\n                    results.append(node)\n                    break\n        return results\n\n    def find_nodes_by_label(self, label: str, limit: int = 100) -&gt; List[GraphNode]:\n        return [n for n in self._nodes.values() if n.label == label][:limit]\n\n    # -------------------------------------------------------------------------\n    # UPDATE\n    # -------------------------------------------------------------------------\n\n    def update_node(self, node_id: str, properties: Dict[str, Any]) -&gt; bool:\n        if node_id not in self._nodes:\n            return False\n        self._nodes[node_id].properties.update(properties)\n        return True\n\n    def update_edge(self, edge_id: str, properties: Dict[str, Any]) -&gt; bool:\n        if edge_id not in self._edges:\n            return False\n        self._edges[edge_id].properties.update(properties)\n        return True\n\n    # -------------------------------------------------------------------------\n    # DELETE\n    # -------------------------------------------------------------------------\n\n    def delete_nodes(self, node_ids: List[str], cascade: bool = True) -&gt; int:\n        count = 0\n        for nid in node_ids:\n            if nid in self._nodes:\n                del self._nodes[nid]\n                count += 1\n                if cascade:\n                    to_remove = [eid for eid, e in self._edges.items()\n                                 if e.source_id == nid or e.target_id == nid]\n                    for eid in to_remove:\n                        del self._edges[eid]\n        return count\n\n    def delete_edges(self, edge_ids: List[str]) -&gt; int:\n        count = 0\n        for eid in edge_ids:\n            if eid in self._edges:\n                del self._edges[eid]\n                count += 1\n        return count\n\n    # -------------------------------------------------------------------------\n    # LIFECYCLE\n    # -------------------------------------------------------------------------\n\n    def get_schema(self) -&gt; Dict[str, Any]:\n        labels = set(n.label for n in self._nodes.values())\n        types = set(e.relation_type for e in self._edges.values())\n        return {\n            \"node_labels\": list(labels),\n            \"edge_types\": list(types),\n            \"counts\": {\n                \"nodes\": len(self._nodes),\n                \"edges\": len(self._edges)\n            }\n        }\n\n    def import_graph(self, graph_data: GraphContext, merge_strategy: str = \"overwrite\") -&gt; Dict[str, int]:\n        nodes_created = 0\n        edges_created = 0\n        \n        for node in graph_data.nodes:\n            if merge_strategy == \"skip\" and node.id in self._nodes:\n                continue\n            self._nodes[node.id] = node\n            nodes_created += 1\n            \n        for edge in graph_data.edges:\n            if merge_strategy == \"skip\" and edge.id in self._edges:\n                continue\n            self._edges[edge.id] = edge\n            edges_created += 1\n            \n        return {\"nodes_created\": nodes_created, \"edges_created\": edges_created}\n\n    def export_graph(self, filter_query: Optional[GraphQuery] = None) -&gt; GraphContext:\n        return GraphContext(\n            nodes=list(self._nodes.values()),\n            edges=list(self._edges.values()),\n            metadata={\"exported_at\": \"now\"}\n        )\n\n\nimport uuid\n\n# Test the example plugin\nplugin = InMemoryGraphPlugin()\nplugin.initialize()\n\nprint(f\"Plugin: {plugin.name} v{plugin.version}\")\n\nPlugin: in-memory-graph v1.0.0\n\n\n\n# Create some nodes\nalice_id = str(uuid.uuid4())\nbob_id = str(uuid.uuid4())\nml_id = str(uuid.uuid4())\n\nnodes = [\n    GraphNode(id=alice_id, label=\"Person\", properties={\"name\": \"Alice\"}),\n    GraphNode(id=bob_id, label=\"Person\", properties={\"name\": \"Bob\"}),\n    GraphNode(id=ml_id, label=\"Concept\", properties={\"name\": \"Machine Learning\"})\n]\n\ncreated_ids = plugin.add_nodes(nodes)\nprint(f\"Created {len(created_ids)} nodes\")\n\nCreated 3 nodes\n\n\n\n# Create edges\nedges = [\n    GraphEdge(id=str(uuid.uuid4()), source_id=alice_id, target_id=ml_id, relation_type=\"MENTIONS\"),\n    GraphEdge(id=str(uuid.uuid4()), source_id=bob_id, target_id=ml_id, relation_type=\"MENTIONS\"),\n    GraphEdge(id=str(uuid.uuid4()), source_id=alice_id, target_id=bob_id, relation_type=\"KNOWS\")\n]\n\ncreated_ids = plugin.add_edges(edges)\nprint(f\"Created {len(created_ids)} edges\")\n\nCreated 3 edges\n\n\n\n# Test get_context (neighborhood traversal)\ncontext = plugin.get_context(alice_id, depth=1)\nprint(f\"Alice's neighborhood: {len(context.nodes)} nodes, {len(context.edges)} edges\")\nprint(f\"Neighbors: {[n.properties.get('name', n.label) for n in context.nodes]}\")\n\nAlice's neighborhood: 3 nodes, 2 edges\nNeighbors: ['Alice', 'Machine Learning', 'Bob']\n\n\n\n# Test find_nodes_by_label\npeople = plugin.find_nodes_by_label(\"Person\")\nprint(f\"People: {[p.properties['name'] for p in people]}\")\n\nPeople: ['Alice', 'Bob']\n\n\n\n# Test get_schema\nschema = plugin.get_schema()\nprint(f\"Schema: {schema}\")\n\nSchema: {'node_labels': ['Person', 'Concept'], 'edge_types': ['KNOWS', 'MENTIONS'], 'counts': {'nodes': 3, 'edges': 3}}\n\n\n\n# Test update_node\nplugin.update_node(alice_id, {\"role\": \"speaker\", \"confidence\": 0.95})\nalice = plugin.get_node(alice_id)\nprint(f\"Updated Alice: {alice.properties}\")\n\nUpdated Alice: {'name': 'Alice', 'role': 'speaker', 'confidence': 0.95}\n\n\n\n# Test export/import\nexported = plugin.export_graph()\nprint(f\"Exported: {len(exported.nodes)} nodes, {len(exported.edges)} edges\")\n\n# Import into a new plugin instance\nnew_plugin = InMemoryGraphPlugin()\nnew_plugin.initialize()\nstats = new_plugin.import_graph(exported)\nprint(f\"Import stats: {stats}\")\n\nExported: 3 nodes, 3 edges\nImport stats: {'nodes_created': 3, 'edges_created': 3}\n\n\n\n# Test delete with cascade\ndeleted = plugin.delete_nodes([alice_id], cascade=True)\nprint(f\"Deleted {deleted} node(s)\")\nprint(f\"Remaining: {plugin.get_schema()}\")\n\nDeleted 1 node(s)\nRemaining: {'node_labels': ['Person', 'Concept'], 'edge_types': ['MENTIONS'], 'counts': {'nodes': 2, 'edges': 1}}\n\n\n\n# Cleanup\nplugin.cleanup()\nnew_plugin.cleanup()",
    "crumbs": [
      "Graph Plugin Interface"
    ]
  },
  {
    "objectID": "utils/mermaid.html",
    "href": "utils/mermaid.html",
    "title": "Mermaid Diagram Generation",
    "section": "",
    "text": "Converts a GraphContext into a Mermaid.js flowchart diagram string. The resulting string can be rendered in Markdown environments that support Mermaid (GitHub, Jupyter with extensions, documentation sites, etc.).\n\nsource\n\n\n\ndef context_to_mermaid(\n    ctx:GraphContext, # The GraphContext to visualize\n    direction:str='TD', # Diagram direction: \"TD\" (top-down) or \"LR\" (left-right)\n    node_color_map:Optional=None, # Map of node labels to CSS colors\n)-&gt;str: # Mermaid.js diagram string\n\nConvert a GraphContext into a Mermaid.js diagram string.\n\n\n\n\nimport uuid\nfrom cjm_graph_plugin_system.core import GraphNode, GraphEdge, GraphContext\n\n# Create sample nodes\nalice_id = str(uuid.uuid4())\nbob_id = str(uuid.uuid4())\nml_id = str(uuid.uuid4())\n\nnodes = [\n    GraphNode(id=alice_id, label=\"Person\", properties={\"name\": \"Alice\"}),\n    GraphNode(id=bob_id, label=\"Person\", properties={\"name\": \"Bob\"}),\n    GraphNode(id=ml_id, label=\"Concept\", properties={\"name\": \"Machine Learning\"})\n]\n\n# Create sample edges\nedges = [\n    GraphEdge(id=str(uuid.uuid4()), source_id=alice_id, target_id=ml_id, relation_type=\"MENTIONS\"),\n    GraphEdge(id=str(uuid.uuid4()), source_id=bob_id, target_id=ml_id, relation_type=\"MENTIONS\"),\n    GraphEdge(id=str(uuid.uuid4()), source_id=alice_id, target_id=bob_id, relation_type=\"KNOWS\")\n]\n\n# Create GraphContext\nctx = GraphContext(nodes=nodes, edges=edges)\n\n# Convert to Mermaid\nmermaid_str = context_to_mermaid(ctx)\nprint(mermaid_str)\n\ngraph TD\n    N0[\"Alice\"]\n    N1[\"Bob\"]\n    N2[\"Machine Learning\"]\n    N0 --&gt;|MENTIONS| N2\n    N1 --&gt;|MENTIONS| N2\n    N0 --&gt;|KNOWS| N1\n\n\n\n# Test with node color mapping\ncolor_map = {\n    \"Person\": \"#ffaaaa\",\n    \"Concept\": \"#aaaaff\"\n}\n\nmermaid_styled = context_to_mermaid(ctx, node_color_map=color_map)\nprint(mermaid_styled)\n\ngraph TD\n    N0[\"Alice\"]\n    style N0 fill:#ffaaaa\n    N1[\"Bob\"]\n    style N1 fill:#ffaaaa\n    N2[\"Machine Learning\"]\n    style N2 fill:#aaaaff\n    N0 --&gt;|MENTIONS| N2\n    N1 --&gt;|MENTIONS| N2\n    N0 --&gt;|KNOWS| N1\n\n\n\n# Test left-right direction\nmermaid_lr = context_to_mermaid(ctx, direction=\"LR\")\nprint(mermaid_lr)\n\ngraph LR\n    N0[\"Alice\"]\n    N1[\"Bob\"]\n    N2[\"Machine Learning\"]\n    N0 --&gt;|MENTIONS| N2\n    N1 --&gt;|MENTIONS| N2\n    N0 --&gt;|KNOWS| N1\n\n\n\n# Test with empty context\nempty_ctx = GraphContext(nodes=[], edges=[])\nmermaid_empty = context_to_mermaid(empty_ctx)\nprint(mermaid_empty)\nassert mermaid_empty == \"graph TD\"\n\ngraph TD\n\n\n\n# Test node with special characters in name\nspecial_node = GraphNode(\n    id=str(uuid.uuid4()),\n    label=\"Quote\",\n    properties={\"name\": 'He said \"hello\"'}\n)\nspecial_ctx = GraphContext(nodes=[special_node], edges=[])\nmermaid_special = context_to_mermaid(special_ctx)\nprint(mermaid_special)\nassert \"He said 'hello'\" in mermaid_special  # Double quotes replaced with single quotes\n\ngraph TD\n    N0[\"He said 'hello'\"]\n\n\n\n# Test fallback to label when no name/title property\nlabel_only_node = GraphNode(\n    id=str(uuid.uuid4()),\n    label=\"UnnamedThing\",\n    properties={\"other\": \"value\"}\n)\nlabel_ctx = GraphContext(nodes=[label_only_node], edges=[])\nmermaid_label = context_to_mermaid(label_ctx)\nprint(mermaid_label)\nassert \"UnnamedThing\" in mermaid_label\n\ngraph TD\n    N0[\"UnnamedThing\"]\n\n\n\n# Test that edges referencing missing nodes are skipped\norphan_edge = GraphEdge(\n    id=str(uuid.uuid4()),\n    source_id=\"nonexistent-1\",\n    target_id=\"nonexistent-2\",\n    relation_type=\"BROKEN\"\n)\nsingle_node = GraphNode(id=str(uuid.uuid4()), label=\"Lonely\", properties={\"name\": \"Solo\"})\norphan_ctx = GraphContext(nodes=[single_node], edges=[orphan_edge])\nmermaid_orphan = context_to_mermaid(orphan_ctx)\nprint(mermaid_orphan)\nassert \"BROKEN\" not in mermaid_orphan  # Orphan edge should not appear\n\ngraph TD\n    N0[\"Solo\"]",
    "crumbs": [
      "utils",
      "Mermaid Diagram Generation"
    ]
  },
  {
    "objectID": "utils/mermaid.html#context_to_mermaid",
    "href": "utils/mermaid.html#context_to_mermaid",
    "title": "Mermaid Diagram Generation",
    "section": "",
    "text": "Converts a GraphContext into a Mermaid.js flowchart diagram string. The resulting string can be rendered in Markdown environments that support Mermaid (GitHub, Jupyter with extensions, documentation sites, etc.).\n\nsource\n\n\n\ndef context_to_mermaid(\n    ctx:GraphContext, # The GraphContext to visualize\n    direction:str='TD', # Diagram direction: \"TD\" (top-down) or \"LR\" (left-right)\n    node_color_map:Optional=None, # Map of node labels to CSS colors\n)-&gt;str: # Mermaid.js diagram string\n\nConvert a GraphContext into a Mermaid.js diagram string.\n\n\n\n\nimport uuid\nfrom cjm_graph_plugin_system.core import GraphNode, GraphEdge, GraphContext\n\n# Create sample nodes\nalice_id = str(uuid.uuid4())\nbob_id = str(uuid.uuid4())\nml_id = str(uuid.uuid4())\n\nnodes = [\n    GraphNode(id=alice_id, label=\"Person\", properties={\"name\": \"Alice\"}),\n    GraphNode(id=bob_id, label=\"Person\", properties={\"name\": \"Bob\"}),\n    GraphNode(id=ml_id, label=\"Concept\", properties={\"name\": \"Machine Learning\"})\n]\n\n# Create sample edges\nedges = [\n    GraphEdge(id=str(uuid.uuid4()), source_id=alice_id, target_id=ml_id, relation_type=\"MENTIONS\"),\n    GraphEdge(id=str(uuid.uuid4()), source_id=bob_id, target_id=ml_id, relation_type=\"MENTIONS\"),\n    GraphEdge(id=str(uuid.uuid4()), source_id=alice_id, target_id=bob_id, relation_type=\"KNOWS\")\n]\n\n# Create GraphContext\nctx = GraphContext(nodes=nodes, edges=edges)\n\n# Convert to Mermaid\nmermaid_str = context_to_mermaid(ctx)\nprint(mermaid_str)\n\ngraph TD\n    N0[\"Alice\"]\n    N1[\"Bob\"]\n    N2[\"Machine Learning\"]\n    N0 --&gt;|MENTIONS| N2\n    N1 --&gt;|MENTIONS| N2\n    N0 --&gt;|KNOWS| N1\n\n\n\n# Test with node color mapping\ncolor_map = {\n    \"Person\": \"#ffaaaa\",\n    \"Concept\": \"#aaaaff\"\n}\n\nmermaid_styled = context_to_mermaid(ctx, node_color_map=color_map)\nprint(mermaid_styled)\n\ngraph TD\n    N0[\"Alice\"]\n    style N0 fill:#ffaaaa\n    N1[\"Bob\"]\n    style N1 fill:#ffaaaa\n    N2[\"Machine Learning\"]\n    style N2 fill:#aaaaff\n    N0 --&gt;|MENTIONS| N2\n    N1 --&gt;|MENTIONS| N2\n    N0 --&gt;|KNOWS| N1\n\n\n\n# Test left-right direction\nmermaid_lr = context_to_mermaid(ctx, direction=\"LR\")\nprint(mermaid_lr)\n\ngraph LR\n    N0[\"Alice\"]\n    N1[\"Bob\"]\n    N2[\"Machine Learning\"]\n    N0 --&gt;|MENTIONS| N2\n    N1 --&gt;|MENTIONS| N2\n    N0 --&gt;|KNOWS| N1\n\n\n\n# Test with empty context\nempty_ctx = GraphContext(nodes=[], edges=[])\nmermaid_empty = context_to_mermaid(empty_ctx)\nprint(mermaid_empty)\nassert mermaid_empty == \"graph TD\"\n\ngraph TD\n\n\n\n# Test node with special characters in name\nspecial_node = GraphNode(\n    id=str(uuid.uuid4()),\n    label=\"Quote\",\n    properties={\"name\": 'He said \"hello\"'}\n)\nspecial_ctx = GraphContext(nodes=[special_node], edges=[])\nmermaid_special = context_to_mermaid(special_ctx)\nprint(mermaid_special)\nassert \"He said 'hello'\" in mermaid_special  # Double quotes replaced with single quotes\n\ngraph TD\n    N0[\"He said 'hello'\"]\n\n\n\n# Test fallback to label when no name/title property\nlabel_only_node = GraphNode(\n    id=str(uuid.uuid4()),\n    label=\"UnnamedThing\",\n    properties={\"other\": \"value\"}\n)\nlabel_ctx = GraphContext(nodes=[label_only_node], edges=[])\nmermaid_label = context_to_mermaid(label_ctx)\nprint(mermaid_label)\nassert \"UnnamedThing\" in mermaid_label\n\ngraph TD\n    N0[\"UnnamedThing\"]\n\n\n\n# Test that edges referencing missing nodes are skipped\norphan_edge = GraphEdge(\n    id=str(uuid.uuid4()),\n    source_id=\"nonexistent-1\",\n    target_id=\"nonexistent-2\",\n    relation_type=\"BROKEN\"\n)\nsingle_node = GraphNode(id=str(uuid.uuid4()), label=\"Lonely\", properties={\"name\": \"Solo\"})\norphan_ctx = GraphContext(nodes=[single_node], edges=[orphan_edge])\nmermaid_orphan = context_to_mermaid(orphan_ctx)\nprint(mermaid_orphan)\nassert \"BROKEN\" not in mermaid_orphan  # Orphan edge should not appear\n\ngraph TD\n    N0[\"Solo\"]",
    "crumbs": [
      "utils",
      "Mermaid Diagram Generation"
    ]
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Core Data Structures",
    "section": "",
    "text": "A pointer to external data residing in another plugin’s domain. Used to anchor graph nodes to ground truth (e.g., a specific transcript segment from a transcription plugin).\nThis enables federation via DuckDB - a query can join graph nodes with their source data across isolated plugin databases.\n\nsource\n\n\n\ndef SourceRef(\n    plugin_name:str, table_name:str, row_id:str, segment_slice:Optional=None\n)-&gt;None:\n\nA pointer to external data in another plugin’s domain.\n\n# Test SourceRef creation\nref = SourceRef(\n    plugin_name=\"cjm-transcription-plugin-voxtral-hf\",\n    table_name=\"transcriptions\",\n    row_id=\"b0ceddd3-1234-5678-9abc-def012345678\",\n    segment_slice=\"timestamp:00:10-00:30\"\n)\n\nprint(f\"SourceRef: {ref}\")\nprint(f\"As dict: {ref.to_dict()}\")\n\nSourceRef: SourceRef(plugin_name='cjm-transcription-plugin-voxtral-hf', table_name='transcriptions', row_id='b0ceddd3-1234-5678-9abc-def012345678', segment_slice='timestamp:00:10-00:30')\nAs dict: {'plugin_name': 'cjm-transcription-plugin-voxtral-hf', 'table_name': 'transcriptions', 'row_id': 'b0ceddd3-1234-5678-9abc-def012345678', 'segment_slice': 'timestamp:00:10-00:30'}\n\n\n\n# Test without optional segment_slice\nref_minimal = SourceRef(\n    plugin_name=\"cjm-transcription-plugin-whisper\",\n    table_name=\"segments\",\n    row_id=\"job-123\"\n)\nprint(f\"Minimal SourceRef: {ref_minimal}\")\n\nMinimal SourceRef: SourceRef(plugin_name='cjm-transcription-plugin-whisper', table_name='segments', row_id='job-123', segment_slice=None)",
    "crumbs": [
      "Core Data Structures"
    ]
  },
  {
    "objectID": "core.html#sourceref",
    "href": "core.html#sourceref",
    "title": "Core Data Structures",
    "section": "",
    "text": "A pointer to external data residing in another plugin’s domain. Used to anchor graph nodes to ground truth (e.g., a specific transcript segment from a transcription plugin).\nThis enables federation via DuckDB - a query can join graph nodes with their source data across isolated plugin databases.\n\nsource\n\n\n\ndef SourceRef(\n    plugin_name:str, table_name:str, row_id:str, segment_slice:Optional=None\n)-&gt;None:\n\nA pointer to external data in another plugin’s domain.\n\n# Test SourceRef creation\nref = SourceRef(\n    plugin_name=\"cjm-transcription-plugin-voxtral-hf\",\n    table_name=\"transcriptions\",\n    row_id=\"b0ceddd3-1234-5678-9abc-def012345678\",\n    segment_slice=\"timestamp:00:10-00:30\"\n)\n\nprint(f\"SourceRef: {ref}\")\nprint(f\"As dict: {ref.to_dict()}\")\n\nSourceRef: SourceRef(plugin_name='cjm-transcription-plugin-voxtral-hf', table_name='transcriptions', row_id='b0ceddd3-1234-5678-9abc-def012345678', segment_slice='timestamp:00:10-00:30')\nAs dict: {'plugin_name': 'cjm-transcription-plugin-voxtral-hf', 'table_name': 'transcriptions', 'row_id': 'b0ceddd3-1234-5678-9abc-def012345678', 'segment_slice': 'timestamp:00:10-00:30'}\n\n\n\n# Test without optional segment_slice\nref_minimal = SourceRef(\n    plugin_name=\"cjm-transcription-plugin-whisper\",\n    table_name=\"segments\",\n    row_id=\"job-123\"\n)\nprint(f\"Minimal SourceRef: {ref_minimal}\")\n\nMinimal SourceRef: SourceRef(plugin_name='cjm-transcription-plugin-whisper', table_name='segments', row_id='job-123', segment_slice=None)",
    "crumbs": [
      "Core Data Structures"
    ]
  },
  {
    "objectID": "core.html#graphnode",
    "href": "core.html#graphnode",
    "title": "Core Data Structures",
    "section": "GraphNode",
    "text": "GraphNode\nRepresents an entity in the Context Graph. Each node has:\n\nid: Unique identifier (UUID)\nlabel: Node type (e.g., “Person”, “Concept”, “Correction”)\nproperties: Arbitrary key-value data\nsources: Links to external plugin data for provenance tracking\n\n\nsource\n\nGraphNode\n\ndef GraphNode(\n    id:str, label:str, properties:Dict=&lt;factory&gt;, sources:List=&lt;factory&gt;\n)-&gt;None:\n\nRepresents an entity in the Context Graph.\n\nimport uuid\n\n# Test SourceRef creation\nref = SourceRef(\n    plugin_name=\"cjm-transcription-plugin-voxtral-hf\",\n    table_name=\"transcriptions\",\n    row_id=\"b0ceddd3-1234-5678-9abc-def012345678\",\n    segment_slice=\"timestamp:00:10-00:30\"\n)\n\nprint(f\"SourceRef: {ref}\")\nprint(f\"As dict: {ref.to_dict()}\")\n\n# Test GraphNode creation with sources\nnode = GraphNode(\n    id=str(uuid.uuid4()),\n    label=\"Person\",\n    properties={\"name\": \"Alice\", \"role\": \"speaker\"},\n    sources=[ref]  # Link to transcript segment\n)\n\nprint(f\"GraphNode: {node}\")\nprint(f\"\\nAs dict:\\n{json.dumps(node.to_dict(), indent=2)}\")\n\nSourceRef: SourceRef(plugin_name='cjm-transcription-plugin-voxtral-hf', table_name='transcriptions', row_id='b0ceddd3-1234-5678-9abc-def012345678', segment_slice='timestamp:00:10-00:30')\nAs dict: {'plugin_name': 'cjm-transcription-plugin-voxtral-hf', 'table_name': 'transcriptions', 'row_id': 'b0ceddd3-1234-5678-9abc-def012345678', 'segment_slice': 'timestamp:00:10-00:30'}\nGraphNode: GraphNode(id='efb79afb-4344-4142-aa09-d2715a822eaa', label='Person', properties={'name': 'Alice', 'role': 'speaker'}, sources=[SourceRef(plugin_name='cjm-transcription-plugin-voxtral-hf', table_name='transcriptions', row_id='b0ceddd3-1234-5678-9abc-def012345678', segment_slice='timestamp:00:10-00:30')])\n\nAs dict:\n{\n  \"id\": \"efb79afb-4344-4142-aa09-d2715a822eaa\",\n  \"label\": \"Person\",\n  \"properties\": {\n    \"name\": \"Alice\",\n    \"role\": \"speaker\"\n  },\n  \"sources\": [\n    {\n      \"plugin_name\": \"cjm-transcription-plugin-voxtral-hf\",\n      \"table_name\": \"transcriptions\",\n      \"row_id\": \"b0ceddd3-1234-5678-9abc-def012345678\",\n      \"segment_slice\": \"timestamp:00:10-00:30\"\n    }\n  ]\n}\n\n\n\n# Test minimal node (no properties, no sources)\nconcept = GraphNode(\n    id=str(uuid.uuid4()),\n    label=\"Concept\"\n)\nprint(f\"Minimal node: {concept.to_dict()}\")\n\nMinimal node: {'id': '6c354a53-a620-4bb7-adf2-dc9583915d5d', 'label': 'Concept', 'properties': {}, 'sources': []}",
    "crumbs": [
      "Core Data Structures"
    ]
  },
  {
    "objectID": "core.html#graphedge",
    "href": "core.html#graphedge",
    "title": "Core Data Structures",
    "section": "GraphEdge",
    "text": "GraphEdge\nRepresents a typed relationship between two nodes. Edges are directional (source → target) and can carry properties.\n\nsource\n\nGraphEdge\n\ndef GraphEdge(\n    id:str, source_id:str, target_id:str, relation_type:str, properties:Dict=&lt;factory&gt;\n)-&gt;None:\n\nRepresents a relationship between two nodes.\n\n# Create two nodes and an edge between them\nperson_id = str(uuid.uuid4())\nconcept_id = str(uuid.uuid4())\n\nperson_node = GraphNode(id=person_id, label=\"Person\", properties={\"name\": \"Bob\"})\nconcept_node = GraphNode(id=concept_id, label=\"Concept\", properties={\"name\": \"Machine Learning\"})\n\nedge = GraphEdge(\n    id=str(uuid.uuid4()),\n    source_id=person_id,\n    target_id=concept_id,\n    relation_type=\"MENTIONS\",\n    properties={\"confidence\": 0.95, \"timestamp\": \"00:15:30\"}\n)\n\nprint(f\"Edge: {person_node.properties['name']} --[{edge.relation_type}]--&gt; {concept_node.properties['name']}\")\nprint(f\"\\nAs dict: {edge.to_dict()}\")\n\nEdge: Bob --[MENTIONS]--&gt; Machine Learning\n\nAs dict: {'id': '2b4057bd-4199-4c72-a2da-158d1eb5f886', 'source_id': '205355aa-3dae-426a-a7cd-2ec340dd94b5', 'target_id': '5217de9d-ba75-4443-bea9-18b0a2b3cdfc', 'relation_type': 'MENTIONS', 'properties': {'confidence': 0.95, 'timestamp': '00:15:30'}}",
    "crumbs": [
      "Core Data Structures"
    ]
  },
  {
    "objectID": "core.html#graphcontext",
    "href": "core.html#graphcontext",
    "title": "Core Data Structures",
    "section": "GraphContext",
    "text": "GraphContext\nContainer for graph query results (a subgraph). Implements FileBackedDTO for zero-copy transfer of large subgraphs between Host and Worker processes.\nWhen passed through RemotePluginProxy, large GraphContext objects are automatically serialized to temp files rather than sent inline via JSON.\n\nsource\n\nGraphContext\n\ndef GraphContext(\n    nodes:List, edges:List, metadata:Dict=&lt;factory&gt;\n)-&gt;None:\n\nContainer for graph query results (a subgraph).\n\n# Create two nodes and an edge between them\nperson_id = str(uuid.uuid4())\nconcept_id = str(uuid.uuid4())\n\nperson_node = GraphNode(id=person_id, label=\"Person\", properties={\"name\": \"Bob\"})\nconcept_node = GraphNode(id=concept_id, label=\"Concept\", properties={\"name\": \"Machine Learning\"})\n\nedge = GraphEdge(\n    id=str(uuid.uuid4()),\n    source_id=person_id,\n    target_id=concept_id,\n    relation_type=\"MENTIONS\",\n    properties={\"confidence\": 0.95, \"timestamp\": \"00:15:30\"}\n)\n\nprint(f\"Edge: {person_node.properties['name']} --[{edge.relation_type}]--&gt; {concept_node.properties['name']}\")\nprint(f\"\\nAs dict: {edge.to_dict()}\")\n\n# Test GraphContext creation\ncontext = GraphContext(\n    nodes=[person_node, concept_node],\n    edges=[edge],\n    metadata={\"query\": \"neighbors of Bob\", \"depth\": 1}\n)\n\nprint(f\"GraphContext: {len(context.nodes)} nodes, {len(context.edges)} edges\")\nprint(f\"Metadata: {context.metadata}\")\n\n# Test FileBackedDTO protocol\nprint(f\"Implements FileBackedDTO: {isinstance(context, FileBackedDTO)}\")\n\n# Test to_temp_file (this is what the Proxy calls)\ntemp_path = context.to_temp_file()\nprint(f\"Saved to temp file: {temp_path}\")\n\n# Verify file exists and content\nimport os\nprint(f\"File exists: {os.path.exists(temp_path)}\")\nprint(f\"File size: {os.path.getsize(temp_path)} bytes\")\n\n# Read back and verify\nwith open(temp_path) as f:\n    content = json.load(f)\nprint(f\"\\nFile content keys: {content.keys()}\")\nprint(f\"Nodes count: {len(content['nodes'])}\")\n\n# Clean up\nos.unlink(temp_path)\n\nEdge: Bob --[MENTIONS]--&gt; Machine Learning\n\nAs dict: {'id': '06de15fd-cf41-4dbb-90e0-d875202c148e', 'source_id': '77f4111e-8b2b-41fe-882b-bb7c3fc67ff7', 'target_id': '88eb934d-0309-4cfd-badb-345f1f508cae', 'relation_type': 'MENTIONS', 'properties': {'confidence': 0.95, 'timestamp': '00:15:30'}}\nGraphContext: 2 nodes, 1 edges\nMetadata: {'query': 'neighbors of Bob', 'depth': 1}\nImplements FileBackedDTO: True\nSaved to temp file: /tmp/tmp4aoorh7a.json\nFile exists: True\nFile size: 561 bytes\n\nFile content keys: dict_keys(['nodes', 'edges', 'metadata'])\nNodes count: 2\n\n\n\n# Test from_file round-trip\ntemp_path = context.to_temp_file()\nloaded = GraphContext.from_file(temp_path)\n\nprint(f\"Original: {len(context.nodes)} nodes, {len(context.edges)} edges\")\nprint(f\"Loaded:   {len(loaded.nodes)} nodes, {len(loaded.edges)} edges\")\nprint(f\"Node labels match: {[n.label for n in context.nodes] == [n.label for n in loaded.nodes]}\")\nprint(f\"Edge types match: {[e.relation_type for e in context.edges] == [e.relation_type for e in loaded.edges]}\")\n\nos.unlink(temp_path)\n\nOriginal: 2 nodes, 1 edges\nLoaded:   2 nodes, 1 edges\nNode labels match: True\nEdge types match: True\n\n\n\n# Test from_dict\nctx_dict = context.to_dict()\nloaded_from_dict = GraphContext.from_dict(ctx_dict)\n\nprint(f\"From dict: {len(loaded_from_dict.nodes)} nodes, {len(loaded_from_dict.edges)} edges\")\n\nFrom dict: 2 nodes, 1 edges",
    "crumbs": [
      "Core Data Structures"
    ]
  },
  {
    "objectID": "core.html#graphquery",
    "href": "core.html#graphquery",
    "title": "Core Data Structures",
    "section": "GraphQuery",
    "text": "GraphQuery\nA standardized query object that can represent:\n\nRaw query strings (SQL, Cypher, etc.)\nStructured search parameters\n\nThe depth parameter is used for neighborhood traversals.\n\nsource\n\nGraphQuery\n\ndef GraphQuery(\n    query:str, parameters:Dict=&lt;factory&gt;, limit:int=100, depth:int=1\n)-&gt;None:\n\nA standardized query object for graph operations.\n\n# Test GraphQuery with SQL-style query\nsql_query = GraphQuery(\n    query=\"SELECT * FROM nodes WHERE label = :label\",\n    parameters={\"label\": \"Person\"},\n    limit=50\n)\nprint(f\"SQL Query: {sql_query}\")\nprint(f\"As dict: {sql_query.to_dict()}\")\n\nSQL Query: GraphQuery(query='SELECT * FROM nodes WHERE label = :label', parameters={'label': 'Person'}, limit=50, depth=1)\nAs dict: {'query': 'SELECT * FROM nodes WHERE label = :label', 'parameters': {'label': 'Person'}, 'limit': 50, 'depth': 1}\n\n\n\n# Test GraphQuery for neighborhood traversal\ntraversal_query = GraphQuery(\n    query=\"NEIGHBORS\",\n    parameters={\"start_node\": person_id},\n    depth=2,\n    limit=100\n)\nprint(f\"Traversal Query: {traversal_query}\")\n\nTraversal Query: GraphQuery(query='NEIGHBORS', parameters={'start_node': '74bd93af-afe3-4bd1-b2f8-628808e4c063'}, limit=100, depth=2)\n\n\n\n# Test minimal query\nsimple = GraphQuery(query=\"SELECT * FROM nodes\")\nprint(f\"Simple query defaults: limit={simple.limit}, depth={simple.depth}\")\n\nSimple query defaults: limit=100, depth=1",
    "crumbs": [
      "Core Data Structures"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "cjm-graph-plugin-system",
    "section": "",
    "text": "pip install cjm_graph_plugin_system",
    "crumbs": [
      "cjm-graph-plugin-system"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "cjm-graph-plugin-system",
    "section": "",
    "text": "pip install cjm_graph_plugin_system",
    "crumbs": [
      "cjm-graph-plugin-system"
    ]
  },
  {
    "objectID": "index.html#project-structure",
    "href": "index.html#project-structure",
    "title": "cjm-graph-plugin-system",
    "section": "Project Structure",
    "text": "Project Structure\nnbs/\n├── utils/ (1)\n│   └── mermaid.ipynb  # Convert GraphContext objects to Mermaid.js diagram strings for visualization\n├── core.ipynb              # DTOs for Context Graph operations with FileBackedDTO support for zero-copy transfer\n└── plugin_interface.ipynb  # Domain-specific plugin interface for Context Graphs\nTotal: 3 notebooks across 1 directory",
    "crumbs": [
      "cjm-graph-plugin-system"
    ]
  },
  {
    "objectID": "index.html#module-dependencies",
    "href": "index.html#module-dependencies",
    "title": "cjm-graph-plugin-system",
    "section": "Module Dependencies",
    "text": "Module Dependencies\ngraph LR\n    core[core&lt;br/&gt;Core Data Structures]\n    plugin_interface[plugin_interface&lt;br/&gt;Graph Plugin Interface]\n    utils_mermaid[utils.mermaid&lt;br/&gt;Mermaid Diagram Generation]\n\n    plugin_interface --&gt; core\n    utils_mermaid --&gt; core\n2 cross-module dependencies detected",
    "crumbs": [
      "cjm-graph-plugin-system"
    ]
  },
  {
    "objectID": "index.html#cli-reference",
    "href": "index.html#cli-reference",
    "title": "cjm-graph-plugin-system",
    "section": "CLI Reference",
    "text": "CLI Reference\nNo CLI commands found in this project.",
    "crumbs": [
      "cjm-graph-plugin-system"
    ]
  },
  {
    "objectID": "index.html#module-overview",
    "href": "index.html#module-overview",
    "title": "cjm-graph-plugin-system",
    "section": "Module Overview",
    "text": "Module Overview\nDetailed documentation for each module in the project:\n\nCore Data Structures (core.ipynb)\n\nDTOs for Context Graph operations with FileBackedDTO support for zero-copy transfer\n\n\nImport\nfrom cjm_graph_plugin_system.core import (\n    SourceRef,\n    GraphNode,\n    GraphEdge,\n    GraphContext,\n    GraphQuery\n)\n\n\nClasses\n@dataclass\nclass SourceRef:\n    \"A pointer to external data in another plugin's domain.\"\n    \n    plugin_name: str  # e.g., \"cjm-transcription-plugin-voxtral-hf\"\n    table_name: str  # e.g., \"transcriptions\"\n    row_id: str  # e.g., \"b0ceddd3-...\" (typically a job_id)\n    segment_slice: Optional[str]  # Optional slice: \"char:0-500\" or \"timestamp:00:10-00:20\"\n    \n    def to_dict(self) -&gt; Dict[str, Any]:  # Dictionary representation for JSON serialization\n        \"Convert to dictionary.\"\n@dataclass\nclass GraphNode:\n    \"Represents an entity in the Context Graph.\"\n    \n    id: str  # UUID\n    label: str  # e.g., \"Person\", \"Concept\", \"Correction\"\n    properties: Dict[str, Any] = field(...)  # Arbitrary metadata\n    sources: List[SourceRef] = field(...)  # Links to external plugins\n    \n    def to_dict(self) -&gt; Dict[str, Any]:  # Dictionary representation for JSON serialization\n            \"\"\"Convert to dictionary with nested sources.\"\"\"\n            return {\n                \"id\": self.id,\n        \"Convert to dictionary with nested sources.\"\n@dataclass\nclass GraphEdge:\n    \"Represents a relationship between two nodes.\"\n    \n    id: str  # UUID\n    source_id: str  # Origin node UUID\n    target_id: str  # Destination node UUID\n    relation_type: str  # e.g., \"MENTIONS\", \"CORRECTS\", \"AUTHORED_BY\"\n    properties: Dict[str, Any] = field(...)  # Arbitrary metadata\n    \n    def to_dict(self) -&gt; Dict[str, Any]:  # Dictionary representation for JSON serialization\n        \"Convert to dictionary.\"\n@dataclass\nclass GraphContext:\n    \"Container for graph query results (a subgraph).\"\n    \n    nodes: List[GraphNode]  # Nodes in the subgraph\n    edges: List[GraphEdge]  # Edges in the subgraph\n    metadata: Dict[str, Any] = field(...)  # Query metadata, stats, etc.\n    \n    def to_temp_file(self) -&gt; str:  # Absolute path to temporary JSON file\n            \"\"\"Save graph data to a temp file for zero-copy transfer.\"\"\"\n            tmp = tempfile.NamedTemporaryFile(suffix=\".json\", delete=False, mode='w')\n            \n            data = {\n                \"nodes\": [n.to_dict() for n in self.nodes],\n        \"Save graph data to a temp file for zero-copy transfer.\"\n    \n    def to_dict(self) -&gt; Dict[str, Any]:  # Dictionary representation for JSON serialization\n            \"\"\"Convert to dictionary.\"\"\"\n            return {\n                \"nodes\": [n.to_dict() for n in self.nodes],\n        \"Convert to dictionary.\"\n    \n    def from_file(\n            cls,\n            filepath: str  # Path to JSON file\n        ) -&gt; \"GraphContext\":  # Reconstructed GraphContext\n        \"Load graph context from a JSON file.\"\n    \n    def from_dict(\n            cls,\n            data: Dict[str, Any]  # Dictionary with nodes, edges, metadata\n        ) -&gt; \"GraphContext\":  # Reconstructed GraphContext\n        \"Load graph context from a dictionary.\"\n@dataclass\nclass GraphQuery:\n    \"A standardized query object for graph operations.\"\n    \n    query: str  # Raw query string (SQL, Cypher, etc.)\n    parameters: Dict[str, Any] = field(...)  # Query parameters\n    limit: int = 100  # Max results to return\n    depth: int = 1  # Traversal depth for neighborhood queries\n    \n    def to_dict(self) -&gt; Dict[str, Any]:  # Dictionary representation for JSON serialization\n        \"Convert to dictionary.\"\n\n\n\nMermaid Diagram Generation (mermaid.ipynb)\n\nConvert GraphContext objects to Mermaid.js diagram strings for visualization\n\n\nImport\nfrom cjm_graph_plugin_system.utils.mermaid import (\n    context_to_mermaid\n)\n\n\nFunctions\ndef context_to_mermaid(\n    ctx: GraphContext,  # The GraphContext to visualize\n    direction: str = \"TD\",  # Diagram direction: \"TD\" (top-down) or \"LR\" (left-right)\n    node_color_map: Optional[Dict[str, str]] = None  # Map of node labels to CSS colors\n) -&gt; str:  # Mermaid.js diagram string\n    \"Convert a GraphContext into a Mermaid.js diagram string.\"\n\n\n\nGraph Plugin Interface (plugin_interface.ipynb)\n\nDomain-specific plugin interface for Context Graphs\n\n\nImport\nfrom cjm_graph_plugin_system.plugin_interface import (\n    GraphPlugin\n)\n\n\nClasses\nclass GraphPlugin(PluginInterface):\n    \"Abstract base class for all Context Graph plugins.\"\n    \n    def execute(\n            self,\n            action: str = \"get_schema\",  # Action to perform (see docstring for available actions)\n            **kwargs\n        ) -&gt; Dict[str, Any]:  # JSON-serializable result\n        \"Execute a graph operation. This is the main entry point for RemotePluginProxy.\n\nDispatches to the appropriate method based on `action` parameter.\nAll return values are JSON-serializable dictionaries for HTTP transport.\"\n    \n    def add_nodes(\n            self,\n            nodes: List[GraphNode]  # Nodes to create\n        ) -&gt; List[str]:  # Created node IDs\n        \"Bulk create nodes.\"\n    \n    def add_edges(\n            self,\n            edges: List[GraphEdge]  # Edges to create\n        ) -&gt; List[str]:  # Created edge IDs\n        \"Bulk create edges.\"\n    \n    def get_node(\n            self,\n            node_id: str  # UUID of node to retrieve\n        ) -&gt; Optional[GraphNode]:  # Node or None if not found\n        \"Get a single node by ID.\"\n    \n    def get_edge(\n            self,\n            edge_id: str  # UUID of edge to retrieve\n        ) -&gt; Optional[GraphEdge]:  # Edge or None if not found\n        \"Get a single edge by ID.\"\n    \n    def get_context(\n            self,\n            node_id: str,  # Starting node UUID\n            depth: int = 1,  # Traversal depth (1 = immediate neighbors)\n            filter_labels: Optional[List[str]] = None  # Only include nodes with these labels\n        ) -&gt; GraphContext:  # Subgraph containing node and its neighborhood\n        \"Get the neighborhood of a specific node.\"\n    \n    def find_nodes_by_source(\n            self,\n            source_ref: SourceRef  # External resource reference\n        ) -&gt; List[GraphNode]:  # Nodes attached to this source\n        \"Find all nodes linked to a specific external resource.\"\n    \n    def find_nodes_by_label(\n            self,\n            label: str,  # Node label to search for\n            limit: int = 100  # Max results\n        ) -&gt; List[GraphNode]:  # Matching nodes\n        \"Find nodes by label.\"\n    \n    def update_node(\n            self,\n            node_id: str,  # UUID of node to update\n            properties: Dict[str, Any]  # Properties to merge/update\n        ) -&gt; bool:  # True if successful\n        \"Partial update of node properties.\"\n    \n    def update_edge(\n            self,\n            edge_id: str,  # UUID of edge to update\n            properties: Dict[str, Any]  # Properties to merge/update\n        ) -&gt; bool:  # True if successful\n        \"Partial update of edge properties.\"\n    \n    def delete_nodes(\n            self,\n            node_ids: List[str],  # UUIDs of nodes to delete\n            cascade: bool = True  # Also delete connected edges\n        ) -&gt; int:  # Number of nodes deleted\n        \"Delete nodes (and optionally connected edges).\"\n    \n    def delete_edges(\n            self,\n            edge_ids: List[str]  # UUIDs of edges to delete\n        ) -&gt; int:  # Number of edges deleted\n        \"Delete edges.\"\n    \n    def get_schema(self) -&gt; Dict[str, Any]:  # Graph schema/ontology\n            \"\"\"Return the current ontology/schema of the graph.\"\"\"\n            ...\n    \n        @abstractmethod\n        def import_graph(\n            self,\n            graph_data: GraphContext,  # Data to import\n            merge_strategy: str = \"overwrite\"  # \"overwrite\", \"skip\", or \"merge\"\n        ) -&gt; Dict[str, int]:  # Import statistics {nodes_created, edges_created, ...}\n        \"Return the current ontology/schema of the graph.\"\n    \n    def import_graph(\n            self,\n            graph_data: GraphContext,  # Data to import\n            merge_strategy: str = \"overwrite\"  # \"overwrite\", \"skip\", or \"merge\"\n        ) -&gt; Dict[str, int]:  # Import statistics {nodes_created, edges_created, ...}\n        \"Bulk import a GraphContext (e.g., from backup or another plugin).\"\n    \n    def export_graph(\n            self,\n            filter_query: Optional[GraphQuery] = None  # Optional filter\n        ) -&gt; GraphContext:  # Exported subgraph or full graph\n        \"Export the entire graph or a filtered subset.\"",
    "crumbs": [
      "cjm-graph-plugin-system"
    ]
  }
]